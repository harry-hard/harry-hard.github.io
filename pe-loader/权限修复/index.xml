<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>节区权限处理 :: Hacker Site</title><link>https://harry-hard.github.io/pe-loader/%E6%9D%83%E9%99%90%E4%BF%AE%E5%A4%8D/index.html</link><description/><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sun, 15 Dec 2024 15:30:00 +0800</lastBuildDate><atom:link href="https://harry-hard.github.io/pe-loader/%E6%9D%83%E9%99%90%E4%BF%AE%E5%A4%8D/index.xml" rel="self" type="application/rss+xml"/><item><title>pe节区权限的修复</title><link>https://harry-hard.github.io/pe-loader/%E6%9D%83%E9%99%90%E4%BF%AE%E5%A4%8D/fix-protection/index.html</link><pubDate>Sun, 15 Dec 2024 15:30:00 +0800</pubDate><guid>https://harry-hard.github.io/pe-loader/%E6%9D%83%E9%99%90%E4%BF%AE%E5%A4%8D/fix-protection/index.html</guid><description>Fix Protection PE 文件中的每个节区（Section）在 IMAGE_SECTION_HEADER 中通过 Characteristics 字段定义了初始内存保护属性。例如：
IMAGE_SCN_MEM_EXECUTE (可执行) IMAGE_SCN_MEM_READ (可读) IMAGE_SCN_MEM_WRITE (可写) 内存保护属性转换 将 PE 文件节区的 Characteristics 转换为 Windows 内存保护常量：
PE 节区属性 内存保护属性 (WinAPI) EXECUTE PAGE_EXECUTE READ PAGE_READONLY READ + EXECUTE PAGE_EXECUTE_READ READ + WRITE PAGE_READWRITE READ + WRITE + EXECUTE PAGE_EXECUTE_READWRITE “由于 IMAGE_SECTION_HEADER.Characteristics 是一个位域（bitfield），它可能同时包含多个标志（flags）。例如，检查 IMAGE_SCN_MEM_READ 标志时，必须使用按位与运算符（&amp;），而不是相等性比较（==）。”
代码注释：
BOOL FixMemPermissions(IN ULONG_PTR pPeBaseAddress, IN PIMAGE_NT_HEADERS pImgNtHdrs, IN PIMAGE_SECTION_HEADER pImgSecHdr) { //其中pPeBaseAddress：是使用virtualAlloc分配的PE基地址 //IN PIMAGE_NT_HEADERS pImgNtHdrs：是Headers.NTheaders //IN PIMAGE_SECTION_HEADER pImgSecHdr:是IMAGE_SECTION_HEADER里面的Characteristics for (DWORD i = 0; i &lt; pImgNtHdrs->FileHeader.</description></item><item><title>pe节区权限的修复</title><link>https://harry-hard.github.io/pe-loader/%E6%9D%83%E9%99%90%E4%BF%AE%E5%A4%8D/%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4%E6%9D%83%E9%99%90%E4%BF%AE%E5%A4%8D/index.html</link><pubDate>Sun, 15 Dec 2024 15:30:00 +0800</pubDate><guid>https://harry-hard.github.io/pe-loader/%E6%9D%83%E9%99%90%E4%BF%AE%E5%A4%8D/%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4%E6%9D%83%E9%99%90%E4%BF%AE%E5%A4%8D/index.html</guid><description>内存保护权限修复 每个头的应有之权限都储存在SECTION头的character字段中
通过FIRST_SECTION(NT)访问IMAGE_SECTION_HEADER字段
接下来就很简单了
int numOfSec=pNt->FileHeader.NumberOfSections;//头的数量储存在这里 for(int i=0;i&lt;numOfSec;i++){//处理每个头 DWORD dwprotction=0;//将要赋予的权限 DWORD oldprotc=0; printf("节区%s\t",pSec[i].Name); //单一权限判断 if(pSec[i].Characteristics&amp;IMAGE_SCN_MEM_WRITE){ dwprotction=PAGE_WRITECOPY; } if(pSec[i].Characteristics&amp;IMAGE_SCN_MEM_READ){ dwprotction=PAGE_READONLY; } if(pSec[i].Characteristics&amp;IMAGE_SCN_MEM_EXECUTE){ dwprotction=PAGE_EXECUTE; } //双重权限判断 if((pSec[i].Characteristics&amp;IMAGE_SCN_MEM_WRITE)&amp;&amp; (pSec[i].Characteristics&amp;IMAGE_SCN_MEM_READ)){ dwprotction=PAGE_READWRITE; } if((pSec[i].Characteristics&amp;IMAGE_SCN_MEM_WRITE)&amp;&amp; (pSec[i].Characteristics&amp;IMAGE_SCN_MEM_EXECUTE)){ dwprotction=PAGE_EXECUTE_WRITECOPY; } if((pSec[i].Characteristics&amp;IMAGE_SCN_MEM_READ)&amp;&amp; (pSec[i].Characteristics&amp;IMAGE_SCN_MEM_EXECUTE)){ dwprotction=PAGE_EXECUTE_READ; } //全部权限 if((pSec[i].Characteristics&amp;IMAGE_SCN_MEM_READ)&amp;&amp; (pSec[i].Characteristics&amp;IMAGE_SCN_MEM_EXECUTE)&amp;&amp; (pSec[i].Characteristics&amp;IMAGE_SCN_MEM_WRITE)){ dwprotction=PAGE_EXECUTE_READWRITE; } printf("新保护：0x%08x\n",dwprotction); //通过VirtualProtect赋予新权限 if(!VirtualProtect(peBase+pSec[i].VirtualAddress, //这里当VirtualSize为0时才使用硬盘大小 pSec[i].Misc.VirtualSize?pSec[i].Misc.VirtualSize:pSec[i].SizeOfRawData, dwprotction, &amp;oldprotc)){ printf("VirtualProtect error:0x%08x\n",GetLastError()); return FALSE; } } return TRUE;</description></item></channel></rss>