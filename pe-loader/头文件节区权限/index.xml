<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>权限修复 :: Hacker Site</title>
    <link>http://localhost:1313/pe-loader/%E5%A4%B4%E6%96%87%E4%BB%B6%E8%8A%82%E5%8C%BA%E6%9D%83%E9%99%90/index.html</link>
    <description></description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 15 Dec 2024 15:30:00 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/pe-loader/%E5%A4%B4%E6%96%87%E4%BB%B6%E8%8A%82%E5%8C%BA%E6%9D%83%E9%99%90/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>节区权限修复</title>
      <link>http://localhost:1313/pe-loader/%E5%A4%B4%E6%96%87%E4%BB%B6%E8%8A%82%E5%8C%BA%E6%9D%83%E9%99%90/fix-protection/index.html</link>
      <pubDate>Sun, 15 Dec 2024 15:30:00 +0800</pubDate>
      <guid>http://localhost:1313/pe-loader/%E5%A4%B4%E6%96%87%E4%BB%B6%E8%8A%82%E5%8C%BA%E6%9D%83%E9%99%90/fix-protection/index.html</guid>
      <description>Fix Protection PE 文件中的每个节区（Section）在 IMAGE_SECTION_HEADER 中通过 Characteristics 字段定义了初始内存保护属性。例如：&#xA;IMAGE_SCN_MEM_EXECUTE (可执行) IMAGE_SCN_MEM_READ (可读) IMAGE_SCN_MEM_WRITE (可写) 内存保护属性转换 将 PE 文件节区的 Characteristics 转换为 Windows 内存保护常量：&#xA;PE 节区属性 内存保护属性 (WinAPI) EXECUTE PAGE_EXECUTE READ PAGE_READONLY READ + EXECUTE PAGE_EXECUTE_READ READ + WRITE PAGE_READWRITE READ + WRITE + EXECUTE PAGE_EXECUTE_READWRITE “由于 IMAGE_SECTION_HEADER.Characteristics 是一个位域（bitfield），它可能同时包含多个标志（flags）。例如，检查 IMAGE_SCN_MEM_READ 标志时，必须使用按位与运算符（&amp;），而不是相等性比较（==）。”&#xA;代码注释：&#xA;BOOL FixMemPermissions(IN ULONG_PTR pPeBaseAddress, IN PIMAGE_NT_HEADERS pImgNtHdrs, IN PIMAGE_SECTION_HEADER pImgSecHdr) { //其中pPeBaseAddress：是使用virtualAlloc分配的PE基地址 //IN PIMAGE_NT_HEADERS pImgNtHdrs：是Headers.NTheaders //IN PIMAGE_SECTION_HEADER pImgSecHdr:是IMAGE_SECTION_HEADER里面的Characteristics for (DWORD i = 0; i &lt; pImgNtHdrs-&gt;FileHeader.NumberOfSections; i++) { DWORD dwProtection = PAGE_NOACCESS; // 默认无访问权限 DWORD dwOldProtection = 0x00; // 跳过无效节 if (!pImgSecHdr[i].SizeOfRawData || !pImgSecHdr[i].VirtualAddress) continue; // 按优先级判断组合 DWORD ch = pImgSecHdr[i].Characteristics; if (ch &amp; IMAGE_SCN_MEM_EXECUTE) { if ((ch &amp; IMAGE_SCN_MEM_WRITE) &amp;&amp; (ch &amp; IMAGE_SCN_MEM_READ)) { dwProtection = PAGE_EXECUTE_READWRITE; } else if (ch &amp; IMAGE_SCN_MEM_WRITE) { dwProtection = PAGE_EXECUTE_READWRITE; // WRITE 隐含 READ } else if (ch &amp; IMAGE_SCN_MEM_READ) { dwProtection = PAGE_EXECUTE_READ; } else { dwProtection = PAGE_EXECUTE; } } else { if ((ch &amp; IMAGE_SCN_MEM_WRITE) &amp;&amp; (ch &amp; IMAGE_SCN_MEM_READ)) { dwProtection = PAGE_READWRITE; } else if (ch &amp; IMAGE_SCN_MEM_WRITE) { dwProtection = PAGE_READWRITE; // WRITE 隐含 READ } else if (ch &amp; IMAGE_SCN_MEM_READ) { dwProtection = PAGE_READONLY; } } // 应用保护属性 if (!VirtualProtect( (PVOID)(pPeBaseAddress + pImgSecHdr[i].VirtualAddress), pImgSecHdr[i].SizeOfRawData, dwProtection, &amp;dwOldProtection )) { PRINT_WINAPI_ERR(&#34;VirtualProtect&#34;); return FALSE; } } return TRUE; }</description>
    </item>
  </channel>
</rss>