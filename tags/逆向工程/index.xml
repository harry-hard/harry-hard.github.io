<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>逆向工程 :: Tag :: Hacker Site</title><link>http://hacker0x0ff.red/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/index.html</link><description/><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sat, 15 Mar 2025 15:30:00 +0800</lastBuildDate><atom:link href="http://hacker0x0ff.red/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/index.xml" rel="self" type="application/rss+xml"/><item><title>1.将硬盘上的PE文件写入内存</title><link>http://hacker0x0ff.red/pe-loader/%E5%86%99%E5%85%A5pe%E8%87%B3%E5%86%85%E5%AD%98/index.html</link><pubDate>Sun, 15 Dec 2024 15:30:00 +0800</pubDate><guid>http://hacker0x0ff.red/pe-loader/%E5%86%99%E5%85%A5pe%E8%87%B3%E5%86%85%E5%AD%98/index.html</guid><description>从硬盘映射PE到内存 从硬盘直接读取的PE文件头名为**RawData。
PointerToRawData 字段记录的是该节在 PE 文件中的起始偏移量（以字节为单位）。也就是说，通过这个偏移量，我们可以在磁盘上的 PE 文件中准确找到该节的原始数据。
所以通过以下代码可以将硬盘中的pe文件放到内存中的pe结构中，模拟了windows从硬盘加载PE文件的过程：
// 给PE文件分配内存 if ((pPeBaseAddress = VirtualAlloc(NULL, pPeHdrs->pImgNtHdrs->OptionalHeader.SizeOfImage, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE)) == NULL) { PRINT_WINAPI_ERR("VirtualAlloc"); return FALSE; } // Copying PE headers - IOC // memcpy(pPeBaseAddress, pPeHdrs->pFileBuffer, pPeHdrs->pImgNtHdrs->OptionalHeader.SizeOfHeaders); for (int i = 0; i &lt; pPeHdrs->pImgNtHdrs->FileHeader.NumberOfSections; i++) { memcpy( (PVOID)(pPeBaseAddress + pPeHdrs->pImgSecHdr[i].VirtualAddress),//目的地址：内存地址+RVA (PVOID)((ULONG_PTR)pPeHdrs->pFileBuffer + pPeHdrs->pImgSecHdr[i].PointerToRawData),//源地址：硬盘地址+RVA pPeHdrs->pImgSecHdr[i].SizeOfRawData ); }</description></item><item><title>重定位的处理</title><link>http://hacker0x0ff.red/pe-loader/%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8%E7%9A%84%E5%A4%84%E7%90%86/index.html</link><pubDate>Sun, 15 Dec 2024 15:30:00 +0800</pubDate><guid>http://hacker0x0ff.red/pe-loader/%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8%E7%9A%84%E5%A4%84%E7%90%86/index.html</guid><description>2.重定位PE文件的重定位块和重定位项 当可执行映像加载到的地址与其首选基地址（IMAGE_OPTIONAL_HEADER.ImageBase）不同时，重定位对于调整可执行映像中的硬编码地址是必要的。在大多数情况下，PE 文件会被映射到除 IMAGE_OPTIONAL_HEADER.ImageBase 之外的地址，因此需要对 PE 文件中的某些硬编码地址进行调整。 通过计算得出地址差值：
// The difference between the current PE image base address and its preferable base address. ULONG_PTR uDeltaOffset = pPeBaseAddress - pPreferableAddress; 下面是微软SDK定义的重定位块的头部结构
typedef struct _IMAGE_BASE_RELOCATION { DWORD VirtualAddress; DWORD SizeOfBlock; } IMAGE_BASE_RELOCATION; 并没有对BASE_RELOCATION_ENTRY做出定义，但描述为：
每个重定位条目占用2字节(WORD)
每个重定位条目占用2字节(WORD) 高4位是类型(Type) 低12位是偏移量(Offset) 代码具体实现可以是：
typedef struct _BASE_RELOCATION_ENTRY { WORD	Offset	: 12; //前12字节 WORD	Type	: 4; //后4字节 //WORD总共占16位 } BASE_RELOCATION_ENTRY, * PBASE_RELOCATION_ENTRY; IMAGE_BASE_RELOCATION和BASE_RELOCATION_ENTRY在PE文件中的位置关系是：
+——————————–+——————+——————+— | IMAGE_BASE_RELOCATION (8字节) | 重定位条目1 | 重定位条目2 | … | - VirtualAddress (4字节) | (2字节) | (2字节) | | - SizeOfBlock (4字节) | | | +—————————————-+—————-+———–+— ↑ ↑ pImgBaseRelocation pImgBaseRelocation + 1</description></item><item><title>导入表修复</title><link>http://hacker0x0ff.red/pe-loader/iat%E4%BF%AE%E5%A4%8D/index.html</link><pubDate>Sun, 15 Dec 2024 15:30:00 +0800</pubDate><guid>http://hacker0x0ff.red/pe-loader/iat%E4%BF%AE%E5%A4%8D/index.html</guid><description>IAT修复 IAT修复有双层循环，第一层循环是判断还有没有dll文件，第二层循环是判断dll内的函数到没到头。
导入表的访问从IMAGE_DATA_DIRECTORY结构开始
pehdr.peNtHdr->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT]
在pe的基地址加上这个IMAGE_DATA_DIRECTORY的VA，访问到第一个PIMAGE_IMPORT_DESCRIPTOR结构
IMAGE_IMPORT_DESCRIPTOR 结构体布局
| 偏移 | 字段名称 | 类型 | 大小(字节) | 说明 |
|——|———-|——|————|——|
| 0x00 | OriginalFirstThunk | DWORD | 4 | 指向 INT (导入名称表) 的 RVA |
| 0x04 | TimeDateStamp | DWORD | 4 | 时间戳，0表示未绑定 |
| 0x08 | ForwarderChain | DWORD | 4 | 转发链信息 |
| 0x0C | Name | DWORD | 4 | 指向 DLL 名称字符串的 RVA |</description></item><item><title>节区权限处理</title><link>http://hacker0x0ff.red/pe-loader/%E6%9D%83%E9%99%90%E4%BF%AE%E5%A4%8D/index.html</link><pubDate>Sun, 15 Dec 2024 15:30:00 +0800</pubDate><guid>http://hacker0x0ff.red/pe-loader/%E6%9D%83%E9%99%90%E4%BF%AE%E5%A4%8D/index.html</guid><description>Fix Protection PE 文件中的每个节区（Section）在 IMAGE_SECTION_HEADER 中通过 Characteristics 字段定义了初始内存保护属性。例如：
IMAGE_SCN_MEM_EXECUTE (可执行) IMAGE_SCN_MEM_READ (可读) IMAGE_SCN_MEM_WRITE (可写) 内存保护属性转换 将 PE 文件节区的 Characteristics 转换为 Windows 内存保护常量：
PE 节区属性 内存保护属性 (WinAPI) EXECUTE PAGE_EXECUTE READ PAGE_READONLY READ + EXECUTE PAGE_EXECUTE_READ READ + WRITE PAGE_READWRITE READ + WRITE + EXECUTE PAGE_EXECUTE_READWRITE “由于 IMAGE_SECTION_HEADER.Characteristics 是一个位域（bitfield），它可能同时包含多个标志（flags）。例如，检查 IMAGE_SCN_MEM_READ 标志时，必须使用按位与运算符（&amp;），而不是相等性比较（==）。”
代码注释：
BOOL FixMemPermissions(IN ULONG_PTR pPeBaseAddress, IN PIMAGE_NT_HEADERS pImgNtHdrs, IN PIMAGE_SECTION_HEADER pImgSecHdr) { //其中pPeBaseAddress：是使用virtualAlloc分配的PE基地址 //IN PIMAGE_NT_HEADERS pImgNtHdrs：是Headers.NTheaders //IN PIMAGE_SECTION_HEADER pImgSecHdr:是IMAGE_SECTION_HEADER里面的Characteristics for (DWORD i = 0; i &lt; pImgNtHdrs->FileHeader.</description></item><item><title>hacker 0x0ff</title><link>http://hacker0x0ff.red/index.html</link><pubDate>Sat, 15 Mar 2025 15:30:00 +0800</pubDate><guid>http://hacker0x0ff.red/index.html</guid><description>欢迎我的朋友 👋 你好！我是 Harry，一名专注于Windows系统恶意软件分析的安全研究员。
我的研究领域 🔍 恶意软件逆向工程与分析 🛡️ Windows系统漏洞研究 � 病毒行为特征提取 🚫 反病毒规避技术研究 📊 威胁情报分析 常用技术栈 工具集： - IDA Pro - OllyDbg - WinDbg - Wireshark - VirtualBox沙箱环境 编程语言： - C（样本复现） - Python（自动化分析） - PowerShell（系统检测） - Assembly（逆向工程） 最新研究重点 目前正在深入分析以下方向的恶意软件样本：
反射式dll注入(202502至今)
反射式dll注入
PE文件加载器(2024-12至2025-02)
PE Loader</description></item><item><title>pe loader</title><link>http://hacker0x0ff.red/pe-loader/index.html</link><pubDate>Sun, 15 Dec 2024 15:30:00 +0800</pubDate><guid>http://hacker0x0ff.red/pe-loader/index.html</guid><description>Local PE Injection 把PE(可执行)文件映射到内存并使之成功执行，和shellcode不一样，shellcode注入简单，PE映射困难(.exe .dll)
IAT修复
写入PE至内存
权限修复
编译器选择
重定位表的处理</description></item><item><title>reflective DLL injection</title><link>http://hacker0x0ff.red/reflectivedllinjection/index.html</link><pubDate>Sun, 15 Dec 2024 15:30:00 +0800</pubDate><guid>http://hacker0x0ff.red/reflectivedllinjection/index.html</guid><description>函数总览
导出表获取
注意事项
windbg调试</description></item><item><title>windbg访问peb结构</title><link>http://hacker0x0ff.red/reflectivedllinjection/windbg_peb/index.html</link><pubDate>Sun, 15 Dec 2024 15:30:00 +0800</pubDate><guid>http://hacker0x0ff.red/reflectivedllinjection/windbg_peb/index.html</guid><description>对于peb来说，ldr结构体指向的PEB_LDR_DATA结构;
PEB_LDR_DATA包含InMemoryOrderModuleList
InMemoryOrderModuleList 是链表的头节点
#首先更新符号： .reload /f ntdll.dll #查看peb，可以区分是x86还是x64: !peb 虽然是amd64架构，但程序是x86
（下文InMemoryOrderModuleList和InMemoryOrderLinks不要搞混）
所以有PEB_LDR_DATA→InMemoryOrderModuleList
InMemoryOrderModuleList→Flink，
Flink包含的指针指向LDR_DATA_TABLE_ENTRY
在LDR_DATA_TABLE_ENTRY 中又有InMemoryOrderLinks （和InMemoryOrderModuleList完全不是一回事，其中InMemoryOrderModuleList 是头节点，而InMemoryOrderLinks 是链表的组成部分）
**InMemoryOrderModuleList**32位进程中，于PEB_LDR_DATA中的偏移（offset）为0x14,
64位偏移为0x20;
InMemoryOrderLinks 32位进程中，在LDR_DATA_TABLE_ENTRY中的偏移为0x08，
64位偏移为0x10;
classDiagram class PEB { +0x00 Ldr : Ptr64 _PEB_LDR_DATA } class PEB_LDR_DATA { +0x00 Length : Uint4B +0x04 Initialized : UChar +0x08 SsHandle : Ptr64 Void +0x10 InLoadOrderModuleList : _LIST_ENTRY (32位偏移: 0x0C) +0x20 InMemoryOrderModuleList : _LIST_ENTRY (32位偏移: 0x14 | 64位偏移: 0x20) +0x30 InInitializationOrderModuleList : _LIST_ENTRY } class LDR_DATA_TABLE_ENTRY { +0x00 InLoadOrderLinks : _LIST_ENTRY (链表节点1) +0x08 InMemoryOrderLinks : _LIST_ENTRY (32位偏移: 0x08 | 64位偏移: 0x10) +0x10 InInitializationOrderLinks : _LIST_ENTRY +0x18 DllBase : Ptr64 Void +0x20 BaseDllName : _UNICODE_STRING } class _LIST_ENTRY { +0x00 Flink : Ptr64 _LIST_ENTRY +0x08 Blink : Ptr64 _LIST_ENTRY } PEB --> PEB_LDR_DATA : Ldr PEB_LDR_DATA --> _LIST_ENTRY : InMemoryOrderModuleList (头节点) _LIST_ENTRY --> LDR_DATA_TABLE_ENTRY : Flink -> InMemoryOrderLinks (链表节点) 1.</description></item><item><title>更多导入表内容</title><link>http://hacker0x0ff.red/pe-loader/iat%E4%BF%AE%E5%A4%8D/%E6%9B%B4%E5%A4%9A/index.html</link><pubDate>Sun, 15 Dec 2024 15:30:00 +0800</pubDate><guid>http://hacker0x0ff.red/pe-loader/iat%E4%BF%AE%E5%A4%8D/%E6%9B%B4%E5%A4%9A/index.html</guid><description>IAT dll包含 可以通过IMAGE_IMPORT_DESCRIPTOR访问PE文件中DLL名称，INT，IAT的地址
typedef struct _IMAGE_IMPORT_DESCRIPTOR { union { DWORD Characteristics; // 0 表示结构数组的结束 DWORD OriginalFirstThunk; // 指向 INT (Import Name Table) } DUMMYUNIONNAME; DWORD TimeDateStamp; // 时间戳 DWORD ForwarderChain; // 转发链 DWORD Name; // DLL名称的RVA DWORD FirstThunk; // 指向 IAT (Import Address Table) } IMAGE_IMPORT_DESCRIPTOR; // PE文件的导入表可能是这样的： 导入表 ├── Import Descriptor 1 (kernel32.dll) │ ├── Name: "kernel32.dll" //DLL的名称 │ ├── OriginalFirstThunk: -> [函数1, 函数2, ...] //INT的RVA │ └── FirstThunk: -> [地址1, 地址2, .</description></item><item><title>更重要的...</title><link>http://hacker0x0ff.red/pe-loader/%E7%BC%96%E8%AF%91%E5%99%A8%E9%80%89%E6%8B%A9/index.html</link><pubDate>Sun, 15 Dec 2024 15:30:00 +0800</pubDate><guid>http://hacker0x0ff.red/pe-loader/%E7%BC%96%E8%AF%91%E5%99%A8%E9%80%89%E6%8B%A9/index.html</guid><description>编译器选择</description></item></channel></rss>