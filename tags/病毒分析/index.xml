<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>病毒分析 :: Tag :: Hacker Site</title><link>https://harry-hard.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/index.html</link><description/><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sat, 15 Mar 2025 15:30:00 +0800</lastBuildDate><atom:link href="https://harry-hard.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/index.xml" rel="self" type="application/rss+xml"/><item><title>1.将硬盘上的PE文件写入内存</title><link>https://harry-hard.github.io/pe-loader/%E5%86%99%E5%85%A5pe%E8%87%B3%E5%86%85%E5%AD%98/index.html</link><pubDate>Sun, 15 Dec 2024 15:30:00 +0800</pubDate><guid>https://harry-hard.github.io/pe-loader/%E5%86%99%E5%85%A5pe%E8%87%B3%E5%86%85%E5%AD%98/index.html</guid><description/></item><item><title>重定位的处理</title><link>https://harry-hard.github.io/pe-loader/%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8%E7%9A%84%E5%A4%84%E7%90%86/index.html</link><pubDate>Sun, 15 Dec 2024 15:30:00 +0800</pubDate><guid>https://harry-hard.github.io/pe-loader/%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8%E7%9A%84%E5%A4%84%E7%90%86/index.html</guid><description/></item><item><title>导入表修复</title><link>https://harry-hard.github.io/pe-loader/iat%E4%BF%AE%E5%A4%8D/index.html</link><pubDate>Sun, 15 Dec 2024 15:30:00 +0800</pubDate><guid>https://harry-hard.github.io/pe-loader/iat%E4%BF%AE%E5%A4%8D/index.html</guid><description/></item><item><title>节区权限处理</title><link>https://harry-hard.github.io/pe-loader/%E6%9D%83%E9%99%90%E4%BF%AE%E5%A4%8D/index.html</link><pubDate>Sun, 15 Dec 2024 15:30:00 +0800</pubDate><guid>https://harry-hard.github.io/pe-loader/%E6%9D%83%E9%99%90%E4%BF%AE%E5%A4%8D/index.html</guid><description/></item><item><title>hacker 0x0ff</title><link>https://harry-hard.github.io/index.html</link><pubDate>Sat, 15 Mar 2025 15:30:00 +0800</pubDate><guid>https://harry-hard.github.io/index.html</guid><description>欢迎我的朋友 👋 你好！我是 Harry，一名专注于Windows系统恶意软件分析的安全研究员。
我的研究领域 🔍 恶意软件逆向工程与分析 🛡️ Windows系统漏洞研究 � 病毒行为特征提取 🚫 反病毒规避技术研究 📊 威胁情报分析 常用技术栈 工具集： - IDA Pro - OllyDbg - WinDbg - Wireshark - VirtualBox沙箱环境 编程语言： - C（样本复现） - Python（自动化分析） - PowerShell（系统检测） - Assembly（逆向工程） 最新研究重点 目前正在深入分析以下方向的恶意软件样本：
反射式dll注入(202502至今) PE文件加载器(2024-12至2025-02)</description></item><item><title>pe loader</title><link>https://harry-hard.github.io/pe-loader/index.html</link><pubDate>Sun, 15 Dec 2024 15:30:00 +0800</pubDate><guid>https://harry-hard.github.io/pe-loader/index.html</guid><description>Local PE Injection 把PE(可执行)文件映射到内存并使之成功执行，和shellcode不一样，shellcode注入简单，PE映射困难(.exe .dll)</description></item><item><title>pe节区权限的修复</title><link>https://harry-hard.github.io/pe-loader/%E6%9D%83%E9%99%90%E4%BF%AE%E5%A4%8D/fix-protection/index.html</link><pubDate>Sun, 15 Dec 2024 15:30:00 +0800</pubDate><guid>https://harry-hard.github.io/pe-loader/%E6%9D%83%E9%99%90%E4%BF%AE%E5%A4%8D/fix-protection/index.html</guid><description>Fix Protection PE 文件中的每个节区（Section）在 IMAGE_SECTION_HEADER 中通过 Characteristics 字段定义了初始内存保护属性。例如：
IMAGE_SCN_MEM_EXECUTE (可执行) IMAGE_SCN_MEM_READ (可读) IMAGE_SCN_MEM_WRITE (可写) 内存保护属性转换 将 PE 文件节区的 Characteristics 转换为 Windows 内存保护常量：
PE 节区属性 内存保护属性 (WinAPI) EXECUTE PAGE_EXECUTE READ PAGE_READONLY READ + EXECUTE PAGE_EXECUTE_READ READ + WRITE PAGE_READWRITE READ + WRITE + EXECUTE PAGE_EXECUTE_READWRITE “由于 IMAGE_SECTION_HEADER.Characteristics 是一个位域（bitfield），它可能同时包含多个标志（flags）。例如，检查 IMAGE_SCN_MEM_READ 标志时，必须使用按位与运算符（&amp;），而不是相等性比较（==）。”
代码注释：
BOOL FixMemPermissions(IN ULONG_PTR pPeBaseAddress, IN PIMAGE_NT_HEADERS pImgNtHdrs, IN PIMAGE_SECTION_HEADER pImgSecHdr) { //其中pPeBaseAddress：是使用virtualAlloc分配的PE基地址 //IN PIMAGE_NT_HEADERS pImgNtHdrs：是Headers.NTheaders //IN PIMAGE_SECTION_HEADER pImgSecHdr:是IMAGE_SECTION_HEADER里面的Characteristics for (DWORD i = 0; i &lt; pImgNtHdrs->FileHeader.</description></item><item><title>pe节区权限的修复</title><link>https://harry-hard.github.io/pe-loader/%E6%9D%83%E9%99%90%E4%BF%AE%E5%A4%8D/%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4%E6%9D%83%E9%99%90%E4%BF%AE%E5%A4%8D/index.html</link><pubDate>Sun, 15 Dec 2024 15:30:00 +0800</pubDate><guid>https://harry-hard.github.io/pe-loader/%E6%9D%83%E9%99%90%E4%BF%AE%E5%A4%8D/%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4%E6%9D%83%E9%99%90%E4%BF%AE%E5%A4%8D/index.html</guid><description>内存保护权限修复 每个头的应有之权限都储存在SECTION头的character字段中
通过FIRST_SECTION(NT)访问IMAGE_SECTION_HEADER字段
接下来就很简单了
int numOfSec=pNt->FileHeader.NumberOfSections;//头的数量储存在这里 for(int i=0;i&lt;numOfSec;i++){//处理每个头 DWORD dwprotction=0;//将要赋予的权限 DWORD oldprotc=0; printf("节区%s\t",pSec[i].Name); //单一权限判断 if(pSec[i].Characteristics&amp;IMAGE_SCN_MEM_WRITE){ dwprotction=PAGE_WRITECOPY; } if(pSec[i].Characteristics&amp;IMAGE_SCN_MEM_READ){ dwprotction=PAGE_READONLY; } if(pSec[i].Characteristics&amp;IMAGE_SCN_MEM_EXECUTE){ dwprotction=PAGE_EXECUTE; } //双重权限判断 if((pSec[i].Characteristics&amp;IMAGE_SCN_MEM_WRITE)&amp;&amp; (pSec[i].Characteristics&amp;IMAGE_SCN_MEM_READ)){ dwprotction=PAGE_READWRITE; } if((pSec[i].Characteristics&amp;IMAGE_SCN_MEM_WRITE)&amp;&amp; (pSec[i].Characteristics&amp;IMAGE_SCN_MEM_EXECUTE)){ dwprotction=PAGE_EXECUTE_WRITECOPY; } if((pSec[i].Characteristics&amp;IMAGE_SCN_MEM_READ)&amp;&amp; (pSec[i].Characteristics&amp;IMAGE_SCN_MEM_EXECUTE)){ dwprotction=PAGE_EXECUTE_READ; } //全部权限 if((pSec[i].Characteristics&amp;IMAGE_SCN_MEM_READ)&amp;&amp; (pSec[i].Characteristics&amp;IMAGE_SCN_MEM_EXECUTE)&amp;&amp; (pSec[i].Characteristics&amp;IMAGE_SCN_MEM_WRITE)){ dwprotction=PAGE_EXECUTE_READWRITE; } printf("新保护：0x%08x\n",dwprotction); //通过VirtualProtect赋予新权限 if(!VirtualProtect(peBase+pSec[i].VirtualAddress, //这里当VirtualSize为0时才使用硬盘大小 pSec[i].Misc.VirtualSize?pSec[i].Misc.VirtualSize:pSec[i].SizeOfRawData, dwprotction, &amp;oldprotc)){ printf("VirtualProtect error:0x%08x\n",GetLastError()); return FALSE; } } return TRUE;</description></item><item><title>修复Import Address Table</title><link>https://harry-hard.github.io/pe-loader/iat%E4%BF%AE%E5%A4%8D/iat%E4%BF%AE%E5%A4%8D/index.html</link><pubDate>Sun, 15 Dec 2024 15:30:00 +0800</pubDate><guid>https://harry-hard.github.io/pe-loader/iat%E4%BF%AE%E5%A4%8D/iat%E4%BF%AE%E5%A4%8D/index.html</guid><description>IAT修复 IAT修复有双层循环，第一层循环是判断还有没有dll文件，第二层循环是判断dll内的函数到没到头。
导入表的访问从IMAGE_DATA_DIRECTORY结构开始
pehdr.peNtHdr->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT]
在pe的基地址加上这个IMAGE_DATA_DIRECTORY的VA，访问到第一个PIMAGE_IMPORT_DESCRIPTOR结构
IMAGE_IMPORT_DESCRIPTOR 结构体布局
| 偏移 | 字段名称 | 类型 | 大小(字节) | 说明 |
|——|———-|——|————|——|
| 0x00 | OriginalFirstThunk | DWORD | 4 | 指向 INT (导入名称表) 的 RVA |
| 0x04 | TimeDateStamp | DWORD | 4 | 时间戳，0表示未绑定 |
| 0x08 | ForwarderChain | DWORD | 4 | 转发链信息 |
| 0x0C | Name | DWORD | 4 | 指向 DLL 名称字符串的 RVA |</description></item><item><title>关于IAT</title><link>https://harry-hard.github.io/pe-loader/iat%E4%BF%AE%E5%A4%8D/%E6%9B%B4%E5%A4%9A/%E5%85%B3%E4%BA%8Eiat/index.html</link><pubDate>Sun, 15 Dec 2024 15:30:00 +0800</pubDate><guid>https://harry-hard.github.io/pe-loader/iat%E4%BF%AE%E5%A4%8D/%E6%9B%B4%E5%A4%9A/%E5%85%B3%E4%BA%8Eiat/index.html</guid><description>IAT dll包含 可以通过IMAGE_IMPORT_DESCRIPTOR访问PE文件中DLL名称，INT，IAT的地址
typedef struct _IMAGE_IMPORT_DESCRIPTOR { union { DWORD Characteristics; // 0 表示结构数组的结束 DWORD OriginalFirstThunk; // 指向 INT (Import Name Table) } DUMMYUNIONNAME; DWORD TimeDateStamp; // 时间戳 DWORD ForwarderChain; // 转发链 DWORD Name; // DLL名称的RVA DWORD FirstThunk; // 指向 IAT (Import Address Table) } IMAGE_IMPORT_DESCRIPTOR; // PE文件的导入表可能是这样的： 导入表 ├── Import Descriptor 1 (kernel32.dll) │ ├── Name: "kernel32.dll" //DLL的名称 │ ├── OriginalFirstThunk: -> [函数1, 函数2, ...] //INT的RVA │ └── FirstThunk: -> [地址1, 地址2, .</description></item><item><title>写入pe至内存中</title><link>https://harry-hard.github.io/pe-loader/%E5%86%99%E5%85%A5pe%E8%87%B3%E5%86%85%E5%AD%98/1-%E4%BB%8E%E7%A1%AC%E7%9B%98%E6%98%A0%E5%B0%84pe%E5%88%B0%E5%86%85%E5%AD%98/index.html</link><pubDate>Sun, 15 Dec 2024 15:30:00 +0800</pubDate><guid>https://harry-hard.github.io/pe-loader/%E5%86%99%E5%85%A5pe%E8%87%B3%E5%86%85%E5%AD%98/1-%E4%BB%8E%E7%A1%AC%E7%9B%98%E6%98%A0%E5%B0%84pe%E5%88%B0%E5%86%85%E5%AD%98/index.html</guid><description>1.从硬盘映射PE到内存 从硬盘直接读取的PE文件头名为**RawData。**
PointerToRawData 字段记录的是该节在 PE 文件中的起始偏移量（以字节为单位）。也就是说，通过这个偏移量，我们可以在磁盘上的 PE 文件中准确找到该节的原始数据。
所以通过以下代码可以将硬盘中的pe文件放到内存中的pe结构中，模拟了windows从硬盘加载PE文件的过程：
// 给PE文件分配内存 if ((pPeBaseAddress = VirtualAlloc(NULL, pPeHdrs->pImgNtHdrs->OptionalHeader.SizeOfImage, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE)) == NULL) { PRINT_WINAPI_ERR("VirtualAlloc"); return FALSE; } // Copying PE headers - IOC // memcpy(pPeBaseAddress, pPeHdrs->pFileBuffer, pPeHdrs->pImgNtHdrs->OptionalHeader.SizeOfHeaders); for (int i = 0; i &lt; pPeHdrs->pImgNtHdrs->FileHeader.NumberOfSections; i++) { memcpy( (PVOID)(pPeBaseAddress + pPeHdrs->pImgSecHdr[i].VirtualAddress),//目的地址：内存地址+RVA (PVOID)((ULONG_PTR)pPeHdrs->pFileBuffer + pPeHdrs->pImgSecHdr[i].PointerToRawData),//源地址：硬盘地址+RVA pPeHdrs->pImgSecHdr[i].SizeOfRawData ); }</description></item><item><title>更多导入表内容</title><link>https://harry-hard.github.io/pe-loader/iat%E4%BF%AE%E5%A4%8D/%E6%9B%B4%E5%A4%9A/index.html</link><pubDate>Sun, 15 Dec 2024 15:30:00 +0800</pubDate><guid>https://harry-hard.github.io/pe-loader/iat%E4%BF%AE%E5%A4%8D/%E6%9B%B4%E5%A4%9A/index.html</guid><description/></item><item><title>更重要的...</title><link>https://harry-hard.github.io/pe-loader/%E7%BC%96%E8%AF%91%E5%99%A8%E9%80%89%E6%8B%A9/index.html</link><pubDate>Sun, 15 Dec 2024 15:30:00 +0800</pubDate><guid>https://harry-hard.github.io/pe-loader/%E7%BC%96%E8%AF%91%E5%99%A8%E9%80%89%E6%8B%A9/index.html</guid><description>编译器选择</description></item><item><title>最重要的是编译器</title><link>https://harry-hard.github.io/pe-loader/%E7%BC%96%E8%AF%91%E5%99%A8%E9%80%89%E6%8B%A9/%E7%BC%96%E8%AF%91%E5%99%A8%E9%80%89%E6%8B%A9/index.html</link><pubDate>Sun, 15 Dec 2024 15:30:00 +0800</pubDate><guid>https://harry-hard.github.io/pe-loader/%E7%BC%96%E8%AF%91%E5%99%A8%E9%80%89%E6%8B%A9/%E7%BC%96%E8%AF%91%E5%99%A8%E9%80%89%E6%8B%A9/index.html</guid><description>编译器选择</description></item><item><title>重定位表处理</title><link>https://harry-hard.github.io/pe-loader/%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8%E7%9A%84%E5%A4%84%E7%90%86/2-%E9%87%8D%E5%AE%9A%E4%BD%8Dpe%E6%96%87%E4%BB%B6%E7%9A%84%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%9D%97%E5%92%8C%E9%87%8D%E5%AE%9A%E4%BD%8D%E9%A1%B9/index.html</link><pubDate>Sun, 15 Dec 2024 15:30:00 +0800</pubDate><guid>https://harry-hard.github.io/pe-loader/%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8%E7%9A%84%E5%A4%84%E7%90%86/2-%E9%87%8D%E5%AE%9A%E4%BD%8Dpe%E6%96%87%E4%BB%B6%E7%9A%84%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%9D%97%E5%92%8C%E9%87%8D%E5%AE%9A%E4%BD%8D%E9%A1%B9/index.html</guid><description>2.重定位PE文件的重定位块和重定位项 当可执行映像加载到的地址与其首选基地址（IMAGE_OPTIONAL_HEADER.ImageBase）不同时，重定位对于调整可执行映像中的硬编码地址是必要的。在大多数情况下，PE 文件会被映射到除 IMAGE_OPTIONAL_HEADER.ImageBase 之外的地址，因此需要对 PE 文件中的某些硬编码地址进行调整。 通过计算得出地址差值：
// The difference between the current PE image base address and its preferable base address. ULONG_PTR uDeltaOffset = pPeBaseAddress - pPreferableAddress; 下面是微软SDK定义的重定位块的头部结构
typedef struct _IMAGE_BASE_RELOCATION { DWORD VirtualAddress; DWORD SizeOfBlock; } IMAGE_BASE_RELOCATION; 并没有对BASE_RELOCATION_ENTRY做出定义，但描述为：
每个重定位条目占用2字节(WORD)
每个重定位条目占用2字节(WORD) 高4位是类型(Type) 低12位是偏移量(Offset) 代码具体实现可以是：
typedef struct _BASE_RELOCATION_ENTRY { WORD	Offset	: 12; //前12字节 WORD	Type	: 4; //后4字节 //WORD总共占16位 } BASE_RELOCATION_ENTRY, * PBASE_RELOCATION_ENTRY; IMAGE_BASE_RELOCATION和BASE_RELOCATION_ENTRY在PE文件中的位置关系是：
+——————————–+——————+——————+— | IMAGE_BASE_RELOCATION (8字节) | 重定位条目1 | 重定位条目2 | … | - VirtualAddress (4字节) | (2字节) | (2字节) | | - SizeOfBlock (4字节) | | | +—————————————-+—————-+———–+— ↑ ↑ pImgBaseRelocation pImgBaseRelocation + 1</description></item></channel></rss>