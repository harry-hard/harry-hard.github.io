<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>reflective DLL injection :: Hacker Site</title><link>https://harry-hard.github.io/reflectivedllinjection/index.html</link><description>函数总览
导出表获取
注意事项</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sun, 15 Dec 2024 15:30:00 +0800</lastBuildDate><atom:link href="https://harry-hard.github.io/reflectivedllinjection/index.xml" rel="self" type="application/rss+xml"/><item><title>函数总览</title><link>https://harry-hard.github.io/reflectivedllinjection/%E5%87%BD%E6%95%B0%E6%80%BB%E8%A7%88/index.html</link><pubDate>Sun, 15 Dec 2024 15:30:00 +0800</pubDate><guid>https://harry-hard.github.io/reflectivedllinjection/%E5%87%BD%E6%95%B0%E6%80%BB%E8%A7%88/index.html</guid><description>DLLEXPORT ULONG_PTR WINAPI ReflectiveLoader() { // 1. 定位自身 PE 头（略） // 2. 分配内存并复制 PE 头和节区（略） // 3. 处理重定位 ProcessRelocations(memBase, delta); // 4. 解析导入表 ResolveImports(memBase); // 5. 设置内存权限 SetMemoryProtections(memBase); // 6. 调用 DllMain CallDllMain(memBase, DLL_PROCESS_ATTACH); return memBase; }</description></item><item><title>注意事项1</title><link>https://harry-hard.github.io/reflectivedllinjection/%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/index.html</link><pubDate>Sun, 15 Dec 2024 15:30:00 +0800</pubDate><guid>https://harry-hard.github.io/reflectivedllinjection/%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/index.html</guid><description>在编写dll部分时，为了方便执行dll，我写了一个程序快速执行dll
HMODULE dllname = LoadLibraryA("dll.dll"); if (!dllname) { printf("dllname don't exitsts!\n"); return 0; } ReflectiveLoaderFunc myfuc = (ReflectiveLoaderFunc)GetProcAddress(dllname, "ReflectiveLoader"); myfuc(); 然而这样的程序在反射式dll处理重定位表时会出大问题： • 通过 LoadLibrary 加载的DLL已被系统修改（重定位+导入表处理），.reloc 节可能被丢弃或擦写。</description></item><item><title>获取磁盘dll(未加载)的导出表</title><link>https://harry-hard.github.io/reflectivedllinjection/%E5%AF%BC%E5%87%BA%E8%A1%A8%E8%8E%B7%E5%8F%96%E7%A3%81%E7%9B%98/index.html</link><pubDate>Sun, 15 Dec 2024 15:30:00 +0800</pubDate><guid>https://harry-hard.github.io/reflectivedllinjection/%E5%AF%BC%E5%87%BA%E8%A1%A8%E8%8E%B7%E5%8F%96%E7%A3%81%E7%9B%98/index.html</guid><description>磁盘中的RVA和加载后的RVA访问方式是不同的
如果已经按内存要求加载：
基地址+DataDirectory[0]
如果还是硬盘格式：
偏移量 = RVA - 区段的VirtualAddress + 区段的PointerToRawData 基地址+偏移量
这里主要理解内存格式和硬盘格式对RVA的影响</description></item></channel></rss>